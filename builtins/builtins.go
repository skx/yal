// Package builtins contains the implementations of the lisp-callable
// functions which are implemented in golang.
//
// This package excludes the special forms, which have to be handled
// specially - for example "(let*)", "(if)", and "(eval..)".
package builtins

import (
	"bufio"
	"bytes"
	"crypto/md5"
	"crypto/sha1"
	"crypto/sha256"
	"fmt"
	"math"
	"math/rand"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"runtime"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/skx/yal/env"
	"github.com/skx/yal/primitive"

	_ "embed" // embedded-resource magic
)

//go:embed help.txt
var helpText string

// helpMap contains a map of help-text.
//
// it is populated at init-time, from helpText
var helpMap map[string]string

// regCache is a cache of compiled regular expression objects.
// These may persist between runs because a regular expression object
// is essentially constant.
var regCache map[string]*regexp.Regexp

// symCount is the count of symbols generated by the 'gensym' built-in
// function.
var symCount int

// builtins contains all our built-in functions
var builtins []string

// init ensures that our regexp cache is populated, and that we build
// up a list of help-texts, keyed on function name.
func init() {

	// Create our maps.
	regCache = make(map[string]*regexp.Regexp)
	helpMap = make(map[string]string)

	// Convert the help-text to a string
	help := string(helpText)

	term := ""
	text := ""

	// process the help-text, embedded, line by line
	for _, line := range strings.Split(help, "\n") {

		// end of an entry?  Save it away
		if line == "%%" {
			helpMap[term] = text

			term = ""
			text = ""
			continue
		}
		if len(term) == 0 {
			// no term?  Then save one
			term = line
		} else {
			// Otherwise add the text to it.
			if len(text) > 0 {
				text += "\n"
			}
			text += line
		}
	}

	// All done, our help text should be available at run-time now.
}

// registerBuiltin registers a built-in, at the same time storing
// the name in the "builtins" global.
func registerBuiltin(env *env.Environment, key string, value any) {
	builtins = append(builtins, key)

	// Sort the list
	sort.Strings(builtins)

	env.Set(key, value)
}

// PopulateEnvironment registers our default primitives
func PopulateEnvironment(env *env.Environment) {

	//
	// bind the functions - sorted order
	//
	registerBuiltin(env, "#", &primitive.Procedure{F: expnFn, Help: helpMap["#"], Args: []primitive.Symbol{primitive.Symbol("N"), primitive.Symbol("b")}})
	registerBuiltin(env, "%", &primitive.Procedure{F: modFn, Help: helpMap["%"], Args: []primitive.Symbol{primitive.Symbol("a"), primitive.Symbol("b")}})
	registerBuiltin(env, "*", &primitive.Procedure{F: multiplyFn, Help: helpMap["*"], Args: []primitive.Symbol{primitive.Symbol("N"), primitive.Symbol("arg1..argN")}})
	registerBuiltin(env, "+", &primitive.Procedure{F: plusFn, Help: helpMap["+"], Args: []primitive.Symbol{primitive.Symbol("N"), primitive.Symbol("arg1..argN")}})
	registerBuiltin(env, "-", &primitive.Procedure{F: minusFn, Help: helpMap["-"], Args: []primitive.Symbol{primitive.Symbol("N"), primitive.Symbol("arg1..argN")}})
	registerBuiltin(env, "/", &primitive.Procedure{F: divideFn, Help: helpMap["/"], Args: []primitive.Symbol{primitive.Symbol("N"), primitive.Symbol("arg1..argN")}})
	registerBuiltin(env, "/=", &primitive.Procedure{F: inequalityFn, Help: helpMap["/="], Args: []primitive.Symbol{primitive.Symbol("N"), primitive.Symbol("arg1..argN")}})
	registerBuiltin(env, "<", &primitive.Procedure{F: ltFn, Help: helpMap["<"], Args: []primitive.Symbol{primitive.Symbol("a"), primitive.Symbol("b")}})
	registerBuiltin(env, "=", &primitive.Procedure{F: equalsFn, Help: helpMap["="], Args: []primitive.Symbol{primitive.Symbol("arg1"), primitive.Symbol("arg2 .. argN")}})
	registerBuiltin(env, "arch", &primitive.Procedure{F: archFn, Help: helpMap["arch"]})
	registerBuiltin(env, "base", &primitive.Procedure{F: baseFn, Help: helpMap["base"], Args: []primitive.Symbol{primitive.Symbol("number"), primitive.Symbol("base")}})
	registerBuiltin(env, "body", &primitive.Procedure{F: bodyFn, Help: helpMap["body"], Args: []primitive.Symbol{primitive.Symbol("function")}})
	registerBuiltin(env, "builtins", &primitive.Procedure{F: builtinsFn, Help: helpMap["builtins"], Args: []primitive.Symbol{}})
	registerBuiltin(env, "car", &primitive.Procedure{F: carFn, Help: helpMap["car"], Args: []primitive.Symbol{primitive.Symbol("list")}})
	registerBuiltin(env, "cdr", &primitive.Procedure{F: cdrFn, Help: helpMap["cdr"], Args: []primitive.Symbol{primitive.Symbol("list")}})
	registerBuiltin(env, "char<", &primitive.Procedure{F: charLtFn, Help: helpMap["char<"], Args: []primitive.Symbol{primitive.Symbol("a"), primitive.Symbol("b")}})
	registerBuiltin(env, "char=", &primitive.Procedure{F: charEqualsFn, Help: helpMap["char="], Args: []primitive.Symbol{primitive.Symbol("a"), primitive.Symbol("b")}})
	registerBuiltin(env, "chr", &primitive.Procedure{F: chrFn, Help: helpMap["chr"], Args: []primitive.Symbol{primitive.Symbol("num")}})
	registerBuiltin(env, "cons", &primitive.Procedure{F: consFn, Help: helpMap["cons"], Args: []primitive.Symbol{primitive.Symbol("a"), primitive.Symbol("b")}})
	registerBuiltin(env, "contains?", &primitive.Procedure{F: containsFn, Help: helpMap["contains?"], Args: []primitive.Symbol{primitive.Symbol("hash"), primitive.Symbol("key")}})
	registerBuiltin(env, "date", &primitive.Procedure{F: dateFn, Help: helpMap["date"]})
	registerBuiltin(env, "directory:entries", &primitive.Procedure{F: directoryEntriesFn, Help: helpMap["directory:entries"]})
	registerBuiltin(env, "directory?", &primitive.Procedure{F: directoryFn, Help: helpMap["directory?"], Args: []primitive.Symbol{primitive.Symbol("path")}})
	registerBuiltin(env, "env", &primitive.Procedure{F: envFn, Help: helpMap["env"], Args: []primitive.Symbol{}})
	registerBuiltin(env, "eq", &primitive.Procedure{F: eqFn, Help: helpMap["eq"], Args: []primitive.Symbol{primitive.Symbol("a"), primitive.Symbol("b")}})
	registerBuiltin(env, "error", &primitive.Procedure{F: errorFn, Help: helpMap["error"], Args: []primitive.Symbol{primitive.Symbol("message")}})
	registerBuiltin(env, "exists?", &primitive.Procedure{F: existsFn, Help: helpMap["exists?"], Args: []primitive.Symbol{primitive.Symbol("path")}})
	registerBuiltin(env, "explode", &primitive.Procedure{F: explodeFn, Help: helpMap["explode"], Args: []primitive.Symbol{primitive.Symbol("string")}})
	registerBuiltin(env, "file:lines", &primitive.Procedure{F: fileLinesFn, Help: helpMap["file:lines"], Args: []primitive.Symbol{primitive.Symbol("path")}})
	registerBuiltin(env, "file:read", &primitive.Procedure{F: fileReadFn, Help: helpMap["file:read"], Args: []primitive.Symbol{primitive.Symbol("path")}})
	registerBuiltin(env, "file:stat", &primitive.Procedure{F: fileStatFn, Help: helpMap["file:stat"], Args: []primitive.Symbol{primitive.Symbol("path")}})
	registerBuiltin(env, "file:write", &primitive.Procedure{F: fileWriteFn, Help: helpMap["file:write"], Args: []primitive.Symbol{primitive.Symbol("path"), primitive.Symbol("content")}})
	registerBuiltin(env, "file?", &primitive.Procedure{F: fileFn, Help: helpMap["file?"], Args: []primitive.Symbol{primitive.Symbol("path")}})
	registerBuiltin(env, "gensym", &primitive.Procedure{F: gensymFn, Help: helpMap["gensym"]})
	registerBuiltin(env, "get", &primitive.Procedure{F: getFn, Help: helpMap["get"], Args: []primitive.Symbol{primitive.Symbol("hash"), primitive.Symbol("key")}})
	registerBuiltin(env, "getenv", &primitive.Procedure{F: getenvFn, Help: helpMap["getenv"], Args: []primitive.Symbol{primitive.Symbol("key")}})
	registerBuiltin(env, "glob", &primitive.Procedure{F: globFn, Help: helpMap["glob"], Args: []primitive.Symbol{primitive.Symbol("pattern")}})
	registerBuiltin(env, "help", &primitive.Procedure{F: helpFn, Help: helpMap["help"], Args: []primitive.Symbol{primitive.Symbol("function")}})
	registerBuiltin(env, "join", &primitive.Procedure{F: joinFn, Help: helpMap["join"], Args: []primitive.Symbol{primitive.Symbol("list")}})
	registerBuiltin(env, "keys", &primitive.Procedure{F: keysFn, Help: helpMap["keys"], Args: []primitive.Symbol{primitive.Symbol("hash")}})
	registerBuiltin(env, "list", &primitive.Procedure{F: listFn, Help: helpMap["list"], Args: []primitive.Symbol{primitive.Symbol("arg1"), primitive.Symbol("arg...")}})
	registerBuiltin(env, "match", &primitive.Procedure{F: matchFn, Help: helpMap["match"], Args: []primitive.Symbol{primitive.Symbol("regexp"), primitive.Symbol("str")}})
	registerBuiltin(env, "md5", &primitive.Procedure{F: md5Fn, Help: helpMap["md5"], Args: []primitive.Symbol{primitive.Symbol("string")}})
	registerBuiltin(env, "ms", &primitive.Procedure{F: msFn, Help: helpMap["ms"]})
	registerBuiltin(env, "nil?", &primitive.Procedure{F: nilFn, Help: helpMap["nil?"], Args: []primitive.Symbol{primitive.Symbol("object")}})
	registerBuiltin(env, "now", &primitive.Procedure{F: nowFn, Help: helpMap["now"]})
	registerBuiltin(env, "nth", &primitive.Procedure{F: nthFn, Help: helpMap["nth"], Args: []primitive.Symbol{primitive.Symbol("list"), primitive.Symbol("offset")}})
	registerBuiltin(env, "number", &primitive.Procedure{F: numberFn, Help: helpMap["number"], Args: []primitive.Symbol{primitive.Symbol("str")}})
	registerBuiltin(env, "ord", &primitive.Procedure{F: ordFn, Help: helpMap["ord"], Args: []primitive.Symbol{primitive.Symbol("char")}})
	registerBuiltin(env, "os", &primitive.Procedure{F: osFn, Help: helpMap["os"]})
	registerBuiltin(env, "print", &primitive.Procedure{F: printFn, Help: helpMap["print"], Args: []primitive.Symbol{primitive.Symbol("arg1..argN")}})
	registerBuiltin(env, "random", &primitive.Procedure{F: randomFn, Help: helpMap["random"], Args: []primitive.Symbol{primitive.Symbol("max")}})
	registerBuiltin(env, "set", &primitive.Procedure{F: setFn, Help: helpMap["set"], Args: []primitive.Symbol{primitive.Symbol("hash"), primitive.Symbol("key"), primitive.Symbol("val")}})
	registerBuiltin(env, "sha1", &primitive.Procedure{F: sha1Fn, Help: helpMap["sha1"], Args: []primitive.Symbol{primitive.Symbol("string")}})
	registerBuiltin(env, "sha256", &primitive.Procedure{F: sha256Fn, Help: helpMap["sha256"], Args: []primitive.Symbol{primitive.Symbol("string")}})
	registerBuiltin(env, "shell", &primitive.Procedure{F: shellFn, Help: helpMap["shell"], Args: []primitive.Symbol{primitive.Symbol("list")}})
	registerBuiltin(env, "sort", &primitive.Procedure{F: sortFn, Help: helpMap["sort"], Args: []primitive.Symbol{primitive.Symbol("list")}})
	registerBuiltin(env, "source", &primitive.Procedure{F: sourceFn, Help: helpMap["source"], Args: []primitive.Symbol{primitive.Symbol("symbol")}})
	registerBuiltin(env, "split", &primitive.Procedure{F: splitFn, Help: helpMap["split"], Args: []primitive.Symbol{primitive.Symbol("str"), primitive.Symbol("by")}})
	registerBuiltin(env, "sprintf", &primitive.Procedure{F: sprintfFn, Help: helpMap["sprintf"], Args: []primitive.Symbol{primitive.Symbol("arg1..argN")}})
	registerBuiltin(env, "str", &primitive.Procedure{F: strFn, Help: helpMap["str"], Args: []primitive.Symbol{primitive.Symbol("object")}})
	registerBuiltin(env, "string<", &primitive.Procedure{F: stringLtFn, Help: helpMap["string<"], Args: []primitive.Symbol{primitive.Symbol("a"), primitive.Symbol("b")}})
	registerBuiltin(env, "string=", &primitive.Procedure{F: stringEqualsFn, Help: helpMap["string="], Args: []primitive.Symbol{primitive.Symbol("a"), primitive.Symbol("b")}})
	registerBuiltin(env, "time", &primitive.Procedure{F: timeFn, Help: helpMap["time"]})
	registerBuiltin(env, "type", &primitive.Procedure{F: typeFn, Help: helpMap["type"], Args: []primitive.Symbol{primitive.Symbol("object")}})
	registerBuiltin(env, "vals", &primitive.Procedure{F: valsFn, Help: helpMap["vals"], Args: []primitive.Symbol{primitive.Symbol("hash")}})

}

// Built in functions

// archFn implements (os)
func archFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {
	return primitive.String(runtime.GOARCH)
}


// baseFn implements (base)
func baseFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {
	if len(args) != 2 {
		return primitive.ArityError()
	}

	// Get the value
	n, ok := args[0].(primitive.Number)
	if !ok {
		return primitive.Error("argument not a number")
	}

	// Get the base
	base, ok2 := args[1].(primitive.Number)
	if !ok2 {
		return primitive.Error("argument not a number")
	}

	if int(base) < 2 || int(base) > 36 {
		return primitive.Error("invalid base - must be >=2 and <=36")
	}
	return primitive.String(strconv.FormatInt(int64(n), int(base)))
}

// bodyFn implements (body)
func bodyFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {
	// We need a single argument
	if len(args) != 1 {
		return primitive.ArityError()
	}

	// Which is a function
	proc, ok := args[0].(*primitive.Procedure)

	if !ok {
		return primitive.Error("argument not a procedure")
	}

	if proc.F != nil {
		return primitive.Error("procedure is implemented in golang")
	}

	// Return value
	return primitive.String(proc.Body.ToString())
}

// builtinsFn implements (builtins)
func builtinsFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {

	var ret primitive.List
	for _, entry := range builtins {
		ret = append(ret, primitive.String(entry))
	}
	return ret
}

// carFn implements "car"
func carFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {

	if len(args) != 1 {
		return primitive.ArityError()
	}

	// ensure we received a list
	if _, ok := args[0].(primitive.List); !ok {
		return primitive.Error("argument not a list")
	}

	// If we have at least one entry then return the first
	lst := args[0].(primitive.List)
	if len(lst) > 0 {
		return lst[0]
	}

	// Otherwise return nil
	return primitive.Nil{}
}

// cdrFn implements "cdr"
func cdrFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {

	if len(args) != 1 {
		return primitive.ArityError()
	}

	// ensure we received a list
	if _, ok := args[0].(primitive.List); !ok {
		return primitive.Error("argument not a list")
	}

	lst := args[0].(primitive.List)
	if len(lst) > 0 {
		return lst[1:]
	}
	return primitive.Nil{}
}

// charEqualsFn implements "char="
func charEqualsFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {

	// We need at least two arguments
	if len(args) < 2 {
		return primitive.ArityError()
	}

	// First argument must be a character
	nA, ok := args[0].(primitive.Character)
	if !ok {
		return primitive.Error("argument was not a character")
	}

	// Now we'll loop over all other arguments
	//
	// If we got something that was NOT the same as our
	// initial value we can terminate early but we don't
	// because it is important to also report on failures to
	// validate types - which we can't do if we bail.
	//
	ret := primitive.Bool(true)

	for _, i := range args[1:] {

		// check we have a character
		nB, ok2 := i.(primitive.Character)

		if !ok2 {
			return primitive.Error("argument was not a character")
		}

		// Record our failure, but keep testing in case
		// we have a type violation to report in a later
		// argument.
		if nB != nA {
			ret = primitive.Bool(false)
		}
	}

	return ret
}

// charLtFn implements (char<)
func charLtFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {
	if len(args) != 2 {
		return primitive.ArityError()
	}

	a, ok1 := args[0].(primitive.Character)
	if !ok1 {
		return primitive.Error("argument not a character")
	}

	b, ok2 := args[1].(primitive.Character)
	if !ok2 {
		return primitive.Error("argument not a character")
	}
	return primitive.Bool(a < b)
}

// chrFn is the implementation of (chr ..)
func chrFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {

	if len(args) != 1 {
		return primitive.ArityError()
	}

	if _, ok := args[0].(primitive.Number); !ok {
		return primitive.Error("argument not a number")
	}

	i := args[0].(primitive.Number)
	rune := rune(i)

	return primitive.Character(rune)
}

// consFn implements (cons).
func consFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {
	if len(args) < 1 {
		return primitive.ArityError()
	}

	if len(args) == 1 {
		return primitive.List{args[0]}
	}
	if args[1] == nil || primitive.IsNil(args[1]) {
		return primitive.List{args[0]}
	}
	if _, ok := args[1].(primitive.List); ok {
		return append(primitive.List{args[0]}, args[1].(primitive.List)...)
	}
	return primitive.List{args[0], args[1]}
}

// containsFn implements (contains?)
func containsFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {

	// We need a pair of arguments
	if len(args) != 2 {
		return primitive.ArityError()
	}

	// First is a Hash
	hsh, ok := args[0].(primitive.Hash)
	if !ok {
		return primitive.Error("argument not a hash")
	}

	// The second should be a string, but other things can be converted
	str, ok := args[1].(primitive.String)
	if !ok {
		str = primitive.String(args[1].ToString())
	}

	_, found := hsh.Entries[str.ToString()]
	if found {
		return primitive.Bool(true)
	}

	return primitive.Bool(false)

}

// dateFn returns the current (Weekday, DD, MM, YYYY) as a list.
func dateFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {
	var ret primitive.List

	t := time.Now()

	name := t.Weekday().String()
	day := t.Day()
	mon := int(t.Month())
	year := t.Year()

	ret = append(ret, primitive.String(name))
	ret = append(ret, primitive.Number(day))
	ret = append(ret, primitive.Number(mon))
	ret = append(ret, primitive.Number(year))

	return ret
}

// directoryEntriesFn returns the files beneath given path, recursively.
func directoryEntriesFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {

	// We only need a single argument
	if len(args) != 1 {
		return primitive.ArityError()
	}

	// Which is a string
	pth, ok := args[0].(primitive.String)
	if !ok {
		return primitive.Error("argument not a string")
	}

	var res primitive.List

	_ = filepath.Walk(pth.ToString(), func(path string, info os.FileInfo, err error) error {

		if err != nil {
			return nil
		}

		res = append(res, primitive.String(path))
		return nil
	})

	return res
}

// directoryFn returns whether the given path exists, and is a directory
func directoryFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {

	// We only need a single argument
	if len(args) != 1 {
		return primitive.ArityError()
	}

	// Which is a string
	str, ok := args[0].(primitive.String)
	if !ok {
		return primitive.Error("argument not a string")
	}

	// Stat the entry
	info, err := os.Stat(str.ToString())

	// No error and isDir then true?  Otherwise false
	//
	// i.e. swallow errors
	if err == nil {
		if info.IsDir() {
			return primitive.Bool(true)
		}
	}
	return primitive.Bool(false)
}

// divideFn implements "/"
func divideFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {
	// ensure we have at least one argument
	if len(args) < 1 {
		return primitive.ArityError()
	}

	// the first argument must be a number.
	v, ok := args[0].(primitive.Number)
	if !ok {
		return primitive.Error(fmt.Sprintf("argument '%s' was not a number", args[0].ToString()))
	}

	// If there is only one argument then we return the
	// reciprocal.
	//
	// (i.e. "(/ 3)" == ".3333"
	if len(args) == 1 {
		return primitive.Number(1 / v)
	}

	// now process all the rest of the arguments
	for _, i := range args[1:] {

		// check we have a number
		n, ok := i.(primitive.Number)
		if ok {
			if n == 0 {
				return primitive.Error("attempted division by zero")
			}

			v /= n
		} else {
			return primitive.Error(fmt.Sprintf("argument %s was not a number", i.ToString()))
		}
	}
	return primitive.Number(v)
}

// envFn returns registered "things" from our environment
func envFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {
	// create a new list
	var c primitive.List

	for key, val := range env.Items() {

		v := val.(primitive.Primitive)

		tmp := primitive.NewHash()
		tmp.Set(":name", primitive.String(key))
		tmp.Set(":value", v)

		// Is this a procedure?  If so
		// add the help-text
		proc, ok := v.(*primitive.Procedure)
		if ok {
			if len(proc.Help) > 0 {
				tmp.Set(":help", primitive.String(proc.Help))
			}
		}

		c = append(c, tmp)
	}

	return c
}

// eqFn implements "eq"
func eqFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {
	if len(args) != 2 {
		return primitive.ArityError()
	}

	a := args[0]
	b := args[1]

	if a.Type() != b.Type() {
		return primitive.Bool(false)
	}
	if a.ToString() != b.ToString() {
		return primitive.Bool(false)
	}
	return primitive.Bool(true)
}

// equalsFn implements "="
func equalsFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {

	// We need at least two arguments
	if len(args) < 2 {
		return primitive.ArityError()
	}

	// First argument must be a number.
	nA, ok := args[0].(primitive.Number)
	if !ok {
		return primitive.Error("argument was not a number")
	}

	// Now we'll loop over all other numbers
	//
	// If we got something that was NOT the same as our
	// initial number we can terminate early but we don't
	// because it is important to also report on failures to
	// validate types - which we can't do if we bail.
	//
	ret := primitive.Bool(true)

	for _, i := range args[1:] {

		// check we have a number
		nB, ok2 := i.(primitive.Number)

		if !ok2 {
			return primitive.Error("argument was not a number")
		}

		// Record our failure, but keep testing in case
		// we have a type violation to report in a later
		// argument.
		if nB != nA {
			ret = primitive.Bool(false)
		}
	}

	return ret
}

// errorFn implements "error"
func errorFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {
	if len(args) != 1 {
		return primitive.ArityError()
	}

	str := args[0].ToString()

	// Show any errors to STDERR, which will be swallowed unless
	// running with `-debug`.

	ioHelper := env.GetIOConfig()

	_, _ = ioHelper.STDERR.Write([]byte("(error \"" + str + "\")"))
	_, _ = ioHelper.STDERR.Write([]byte("\n"))

	return primitive.Error(str)
}

// existsFn returns whether the given path exists.
func existsFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {

	// We only need a single argument
	if len(args) != 1 {
		return primitive.ArityError()
	}

	// Which is a string
	str, ok := args[0].(primitive.String)
	if !ok {
		return primitive.Error("argument not a string")
	}

	if _, err := os.Stat(str.ToString()); err == nil {
		// path/to/whatever exists
		return primitive.Bool(true)
	}

	return primitive.Bool(false)
}

// Convert a string such as "steve\tkemp" into "steve<TAB>kemp"
func expandStr(input string) string {
	out := ""

	// Walk the string character by character
	i := 0
	l := len(input)

	for i < l {

		// current character
		c := input[i]

		// look for "\n", "\t", etc.
		if c == '\\' && (i+1) < l {

			next := input[i+1]
			switch next {
			case 'e':
				out += string(rune(033))
			case 't':
				out += "\t"
			case 'n':
				out += "\n"
			case 'r':
				out += "\r"
			case '\\':
				out += "\\"
			default:
				// unknown escapes will be left alone
				out += "\\" + string(next)
			}

			// Bump the count once, to skip the "\".
			//
			// At the end of the loop we bump again, which will
			// skip the character after that
			i++
		} else {
			out += string(c)
		}
		i++
	}

	return out
}

// explodeFn splits a string into a list of characters
func explodeFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {

	// We only need a single argument
	if len(args) != 1 {
		return primitive.ArityError()
	}

	// Which is a string
	str, ok := args[0].(primitive.String)
	if !ok {
		return primitive.Error("argument not a string")
	}

	// Split it
	out := strings.Split(str.ToString(), "")

	// return a list of characters
	var c primitive.List

	for _, x := range out {
		c = append(c, primitive.Character(x))
	}

	return c
}

// expnFn implements "#"
func expnFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {
	if len(args) != 2 {
		return primitive.ArityError()
	}

	if _, ok := args[0].(primitive.Number); !ok {
		return primitive.Error("argument not a number")
	}
	if _, ok := args[1].(primitive.Number); !ok {
		return primitive.Error("argument not a number")
	}
	return primitive.Number(math.Pow(float64(args[0].(primitive.Number)), float64(args[1].(primitive.Number))))
}

// fileFn returns whether the given path exists, and is a file (or rather is not a directory).
func fileFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {
	// We only need a single argument
	if len(args) != 1 {
		return primitive.ArityError()
	}

	// Which is a string
	str, ok := args[0].(primitive.String)
	if !ok {
		return primitive.Error("argument not a string")
	}

	// stat the path
	info, err := os.Stat(str.ToString())

	// no error then return true, unless we've got a directory
	//
	// i.e. swallow errors
	if err == nil {
		if !info.IsDir() {
			return primitive.Bool(true)
		}
	}
	return primitive.Bool(false)
}

// fileLinesFn implements (file:lines)
func fileLinesFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {
	// We only need a single argument
	if len(args) != 1 {
		return primitive.ArityError()
	}

	// Which is a string
	fName, ok := args[0].(primitive.String)
	if !ok {
		return primitive.Error("argument not a string")
	}

	// Return value,
	var res primitive.List

	// Open the file
	file, err := os.Open(fName.ToString())
	if err != nil {
		return primitive.Error(fmt.Sprintf("failed to open %s:%s", fName.ToString(), err))
	}
	defer file.Close()

	// Read each line, and append to our list.
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		res = append(res, primitive.String(scanner.Text()))
	}

	// All done.
	return res
}

// fileReadFn implements (file:read)
func fileReadFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {
	// We only need a single argument
	if len(args) != 1 {
		return primitive.ArityError()
	}

	// Which is a string
	fName, ok := args[0].(primitive.String)
	if !ok {
		return primitive.Error("argument not a string")
	}

	data, err := os.ReadFile(fName.ToString())
	if err != nil {
		return primitive.Error(fmt.Sprintf("error reading %s %s", fName.ToString(), err))
	}
	return primitive.String(string(data))
}

// fileStatFn implements (file:stat)
//
// Return value is (NAME SIZE UID GID MODE)
func fileStatFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {
	// We only need a single argument
	if len(args) != 1 {
		return primitive.ArityError()
	}

	// Which is a string
	fName, ok := args[0].(primitive.String)
	if !ok {
		return primitive.Error("argument not a string")
	}

	// Stat the entry
	info, err := os.Stat(fName.ToString())

	if err != nil {
		return primitive.Nil{}
	}

	// If we're not on Linux the Stat_t type won't be available,
	// so we'd default to the current user.
	UID := os.Getuid()
	GID := os.Getgid()

	// Get the UID in a non-portable way
	u, e := getUID(info)
	if e == nil {
		UID = u
	}

	// Get the GID in a non-portable way
	g, e := getGID(info)
	if e == nil {
		GID = g
	}

	var res primitive.List

	res = append(res, primitive.String(info.Name()))
	res = append(res, primitive.Number(info.Size()))
	res = append(res, primitive.Number(UID))
	res = append(res, primitive.Number(GID))
	res = append(res, primitive.String(info.Mode().String()))

	return res
}

// fileWriteFn implements file:write
func fileWriteFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {
	// We need two arguments
	if len(args) != 2 {
		return primitive.ArityError()
	}

	// Path is a string
	path, ok := args[0].(primitive.String)
	if !ok {
		return primitive.Error("argument not a string")
	}

	// Content is a string
	content, ok := args[1].(primitive.String)
	if !ok {
		return primitive.Error("argument not a string")
	}

	err := os.WriteFile(path.ToString(), []byte(content.ToString()), 0777)
	if err != nil {
		return primitive.Error(fmt.Sprintf("failed to write to %s:%s", path.ToString(), err))
	}
	return primitive.Nil{}
}

// gensymFn is the implementation of (gensym ..)
func gensymFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {
	// symbol characters
	var letters = []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")

	// generate prefix
	b := make([]rune, 5)
	for i := range b {
		b[i] = letters[rand.Intn(len(letters))]
	}

	// generate with count
	symCount++
	str := fmt.Sprintf("%s%06d", string(b), symCount)
	sym := primitive.Symbol(str)
	return sym
}

// getFn is the implementation of `(get hash key)`
func getFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {

	// We need two arguments
	if len(args) != 2 {
		return primitive.ArityError()
	}

	// First is a Hash
	if _, ok := args[0].(primitive.Hash); !ok {
		return primitive.Error("argument not a hash")
	}

	tmp := args[0].(primitive.Hash)
	return tmp.Get(args[1].ToString())
}

// getenvFn is the implementation of `(getenv "PATH")`
func getenvFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {

	// If we have only a single argument
	if len(args) != 1 {
		return primitive.ArityError()
	}

	// Which is a string
	if _, ok := args[0].(primitive.String); !ok {
		return primitive.Error("argument not a string")
	}

	// Return the value
	str := args[0].(primitive.String)
	return primitive.String(os.Getenv(string(str)))
}

// globFn is the implementation of `(glob "pattern")`
func globFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {

	// If we have only a single argument
	if len(args) != 1 {
		return primitive.ArityError()
	}

	// Which is a string
	str, ok := args[0].(primitive.String)
	if !ok {
		return primitive.Error("argument not a string")
	}

	// Run the glob
	out, err := filepath.Glob(str.ToString())

	if err != nil {
		return primitive.Error(fmt.Sprintf("error running glob(%s): %s", str.ToString(), err))
	}

	var ret primitive.List

	for _, ent := range out {
		ret = append(ret, primitive.String(ent))
	}

	return ret
}

// helpFn is the implementation of `(help fn)`
func helpFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {

	// Two arguments?
	if len(args) == 2 {

		name, ok1 := args[0].(primitive.String)
		help, ok2 := args[1].(primitive.String)

		if !ok1 {
			return primitive.Error("when setting help the key must be a string")
		}
		if !ok2 {
			return primitive.Error("when setting help the value must be a string")
		}

		helpMap[name.ToString()] = help.ToString()
		return primitive.Nil{}
	}

	// We need a single argument
	if len(args) != 1 {
		return primitive.ArityError()
	}

	// Lookup by string?
	name, ok1 := args[0].(primitive.String)
	if ok1 {
		// Stored at runtime?
		out, ok := helpMap[name.ToString()]
		if ok {
			return primitive.String(out)
		}
		return primitive.Nil{}
	}

	// Which is a function
	proc, ok := args[0].(*primitive.Procedure)

	if !ok {
		return primitive.Error("argument not a procedure")
	}

	// Return value
	str := ""

	for _, arg := range proc.Args {
		if len(str) == 0 {
			str = "Arguments"
		}
		str += " " + arg.ToString()

		// Default value for this argument?
		def, ok2 := proc.Defaults[arg]
		if ok2 {
			str += "[default:"
			str += def.ToString()
			str += "]"
		}

	}
	if len(str) > 0 {
		str += "\n"
	}
	str += proc.Help
	return primitive.String(str)
}

// inequalityFn implements /=
func inequalityFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {

	// We need at least two arguments
	if len(args) < 2 {
		return primitive.ArityError()
	}

	// First argument must be a number.
	nA, ok := args[0].(primitive.Number)
	if !ok {
		return primitive.Error("argument was not a number")
	}

	// Now we'll loop over all other numbers
	//
	// If we got something that was already seen we can
	// terminate early but we don't because it is important
	// to also report on failures to validate types - which
	// we can't do if we bail.
	//
	ret := primitive.Bool(true)

	// Keep track of things we've seen here
	seen := make(map[float64]bool)
	seen[float64(nA)] = true

	for _, i := range args[1:] {

		// check we have a number
		nB, ok2 := i.(primitive.Number)

		if !ok2 {
			return primitive.Error("argument was not a number")
		}

		// Have we seen this?
		_, found := seen[float64(nB)]
		if found {
			ret = primitive.Bool(false)
		}
		seen[float64(nB)] = true
	}

	return ret
}

// (join (1 2 3)
func joinFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {

	// We require one or two arguments
	if len(args) != 1 && len(args) != 2 {
		return primitive.ArityError()
	}

	// The argument must be a list
	lst, ok := args[0].(primitive.List)
	if !ok {
		return primitive.Error("argument not a list")
	}

	ln := len(lst)

	tmp := ""
	sep := ""

	// If we got a separator then save it away
	if len(args) == 2 {
		sep = args[1].ToString()
	}

	for i, t := range lst {

		// Add the entry
		tmp += t.ToString()

		// Add the separator, unless it's the last entry
		if i != (ln - 1) {
			tmp += sep
		}
	}

	return primitive.String(tmp)
}

// keysFn is the implementation of `(keys hash)`
func keysFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {

	// We need a single argument
	if len(args) != 1 {
		return primitive.ArityError()
	}

	// First is a Hash
	if _, ok := args[0].(primitive.Hash); !ok {
		return primitive.Error("argument not a hash")
	}

	// Create the list to hold the result
	var c primitive.List

	// Cast the argument
	tmp := args[0].(primitive.Hash)

	// Get the keys as a list
	keys := []string{}

	// Add the keys
	for x := range tmp.Entries {
		keys = append(keys, x)
	}

	// Sort the list
	sort.Strings(keys)

	// Now append
	for _, x := range keys {
		c = append(c, primitive.String(x))
	}

	return c
}

// listFn implements "list"
func listFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {
	return primitive.List(args)
}

// ltFn implements "<"
func ltFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {
	if len(args) != 2 {
		return primitive.ArityError()
	}

	if _, ok := args[0].(primitive.Number); !ok {
		return primitive.Error("argument not a number")
	}
	if _, ok := args[1].(primitive.Number); !ok {
		return primitive.Error("argument not a number")
	}
	return primitive.Bool(args[0].(primitive.Number) < args[1].(primitive.Number))
}

// matchFn is the implementation of (match ..)
func matchFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {

	// We need two arguments
	if len(args) != 2 {
		return primitive.ArityError()
	}

	// First argument is a string (which is a regexp)
	if _, ok := args[0].(primitive.String); !ok {
		return primitive.Error("argument not a string")
	}

	// Second is what we'll match
	pat := args[0].ToString()
	txt := args[1].ToString()

	// Look for a cached regexp
	r, ok := regCache[pat]
	if !ok {
		// OK it wasn't found, so compile it.
		var err error
		r, err = regexp.Compile(pat)

		// Ensure it compiled
		if err != nil {
			return primitive.Error(fmt.Sprintf("failed to compile regexp '%s':%s", pat, err.Error()))
		}

		// store in the cache for next time
		regCache[pat] = r
	}

	res := r.FindStringSubmatch(txt)

	if len(res) > 0 {

		// Return the items in a list
		var tmp primitive.List

		if len(res) > 0 {
			for i := 0; i < len(res); i++ {

				tmp = append(tmp, primitive.String(res[i]))
			}
		}

		return tmp
	}

	// No match
	return primitive.Nil{}

}

// minusFn implements "-"
func minusFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {

	// ensure we have at least one argument
	if len(args) < 1 {
		return primitive.ArityError()
	}

	// the first argument must be a number.
	v, ok := args[0].(primitive.Number)
	if !ok {
		return primitive.Error(fmt.Sprintf("argument '%s' was not a number", args[0].ToString()))
	}

	// now process all the rest of the arguments
	for _, i := range args[1:] {

		// check we have a number
		n, ok := i.(primitive.Number)
		if ok {
			v -= n
		} else {
			return primitive.Error(fmt.Sprintf("argument %s was not a number", i.ToString()))
		}
	}
	return primitive.Number(v)
}

// modFn implements "%"
func modFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {
	if len(args) != 2 {
		return primitive.ArityError()
	}
	if _, ok := args[0].(primitive.Number); !ok {
		return primitive.Error("argument not a number")
	}
	if _, ok := args[1].(primitive.Number); !ok {
		return primitive.Error("argument not a number")
	}

	a := int(args[0].(primitive.Number))
	b := int(args[1].(primitive.Number))
	if b == 0 {
		return primitive.Error("attempted division by zero")
	}
	return primitive.Number(a % b)
}

// md5Fn is the implementation of `(md5)`
func md5Fn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {
	// We need one argument
	if len(args) != 1 {
		return primitive.ArityError()
	}

	// The argument must be a string
	str := args[0].ToString()

	// Get the output
	return primitive.String(fmt.Sprintf("%X", md5.Sum([]byte(str))))
}

// msFn is the implementation of `(ms)`
func msFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {
	return primitive.Number(time.Now().UnixNano() / int64(time.Millisecond))
}

// multiplyFn implements "*"
func multiplyFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {
	// ensure we have at least one argument
	if len(args) < 1 {
		return primitive.ArityError()
	}

	// the first argument must be a number.
	v, ok := args[0].(primitive.Number)
	if !ok {
		return primitive.Error(fmt.Sprintf("argument '%s' was not a number", args[0].ToString()))
	}

	// now process all the rest of the arguments
	for _, i := range args[1:] {

		// check we have a number
		n, ok := i.(primitive.Number)
		if ok {
			v *= n
		} else {
			return primitive.Error(fmt.Sprintf("argument %s was not a number", i.ToString()))
		}
	}
	return primitive.Number(v)
}

// nilFn implements nil?
func nilFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {
	if len(args) != 1 {
		return primitive.ArityError()
	}

	// nil is nil (yeah, really)
	if primitive.IsNil(args[0]) {
		return primitive.Bool(true)
	}

	// an empty list is nil.
	if list, ok := args[0].(primitive.List); ok {
		return primitive.Bool(len(list) == 0)
	}
	return primitive.Bool(false)

}

// nowFn is the implementation of `(now)`
func nowFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {
	return primitive.Number(time.Now().Unix())
}

// nthFn is the implementation of `(nth..)`
func nthFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {

	// We need two arguments.
	if len(args) != 2 {
		return primitive.ArityError()
	}

	// The argument must be a list
	lst, ok := args[0].(primitive.List)
	if !ok {
		return primitive.Error("argument not a list")
	}

	// The second argument must be a number
	num, ok2 := args[1].(primitive.Number)
	if !ok2 {
		return primitive.Error("argument not a number")
	}

	n := int(num)

	// Is it in bound?
	if n >= 0 && n < len(lst) {
		return lst[n]
	}

	return primitive.Error("out of bounds")
}

// numberFn is the implementation of (number ..)
func numberFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {
	// we only accept a single parameter
	if len(args) != 1 {
		return primitive.ArityError()
	}

	// The argument must be a string
	str, ok := args[0].(primitive.String)
	if !ok {
		return primitive.Error("argument not a string")
	}

	// Lower-case so our prefix-matching works
	s := strings.ToLower(str.ToString())
	if strings.HasPrefix(s, "0x") || strings.HasPrefix(s, "0b") {

		// If so then parse as an integer
		n, err := strconv.ParseInt(s, 0, 32)
		if err == nil {
			return primitive.Number(n)
		}
	}

	// Is it a number?
	f, err := strconv.ParseFloat(s, 64)
	if err == nil {

		return primitive.Number(f)
	}

	return primitive.Error(fmt.Sprintf("failed to convert %s to number", args[0].ToString()))
}

// ordFn is the implementation of (ord ..)
func ordFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {

	if len(args) != 1 {
		return primitive.ArityError()
	}

	// We work on strings, or characters
	switch args[0].Type() {
	case "character":
		// nop
	case "string":
		// nop
	default:
		return primitive.Error(fmt.Sprintf("argument not a character/string, got %v", args[0].Type()))
	}

	// We convert this to an array of runes because we
	// want to handle unicode strings.
	i := []rune(args[0].ToString())

	if len(i) > 0 {
		s := rune(i[0])
		return primitive.Number(float64(rune(s)))
	}
	return primitive.Number(0)
}

// osFn implements (os)
func osFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {
	return primitive.String(runtime.GOOS)
}

// plusFn implements "+"
func plusFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {

	// ensure we have at least one argument
	if len(args) < 1 {
		return primitive.ArityError()
	}

	// the first argument must be a number.
	v, ok := args[0].(primitive.Number)
	if !ok {
		return primitive.Error(fmt.Sprintf("argument '%s' was not a number", args[0].ToString()))
	}

	// now process all the rest of the arguments
	for _, i := range args[1:] {

		// check we have a number
		n, ok := i.(primitive.Number)
		if ok {
			v += n
		} else {
			return primitive.Error(fmt.Sprintf("argument %s was not a number", i.ToString()))
		}
	}
	return primitive.Number(v)
}

// printFn implements (print).
func printFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {
	// no args
	if len(args) < 1 {
		return primitive.ArityError()
	}

	ioHelper := env.GetIOConfig()

	// one arg
	if len(args) == 1 {
		// expand
		str := expandStr(args[0].ToString())

		// Write via our configuration object
		// Linter complains about ignored return values here..
		_, _ = ioHelper.STDOUT.Write([]byte(str))
		_, _ = ioHelper.STDOUT.Write([]byte("\n"))

		return primitive.String(str)
	}

	// OK format-string
	frmt := expandStr(args[0].ToString())
	parm := []any{}

	for _, a := range args[1:] {

		// If we can use ToNative then do that,
		// otherwise fall back to outputting a string.
		native, ok := a.(primitive.ToNative)
		if ok {
			parm = append(parm, native.ToInterface())
		} else {
			parm = append(parm, a.ToString())
		}
	}

	out := fmt.Sprintf(frmt, parm...)

	// Write via our configuration object
	// Linter complains about ignored return values here..
	_, _ = ioHelper.STDOUT.Write([]byte(out))
	_, _ = ioHelper.STDOUT.Write([]byte("\n"))

	return primitive.String(out)
}

// randomFn implements (random).
func randomFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {
	if len(args) != 1 {
		return primitive.ArityError()
	}

	// ensure we received a number
	num, ok := args[0].(primitive.Number)

	if !ok {
		return primitive.Error("argument not a number")
	}

	if int(num) <= 0 {
		return primitive.Error("argument must be greater than zero")
	}

	return primitive.Number(rand.Intn(int(num)))

}

// setFn is the implementation of `(set hash key val)`
func setFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {

	// We need three arguments
	if len(args) != 3 {
		return primitive.ArityError()
	}

	// First is a Hash
	if _, ok := args[0].(primitive.Hash); !ok {
		return primitive.Error("argument not a hash")
	}

	tmp := args[0].(primitive.Hash)
	tmp.Set(args[1].ToString(), args[2])
	return args[2]
}

// sha1Fn runs a SHA1 hash
func sha1Fn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {
	// We need one argument
	if len(args) != 1 {
		return primitive.ArityError()
	}

	// The argument must be a string
	str := args[0].ToString()

	// Get the output
	return primitive.String(fmt.Sprintf("%X", sha1.Sum([]byte(str))))
}

// sha256Fn runs a SHA256 hash
func sha256Fn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {
	// We need one argument
	if len(args) != 1 {
		return primitive.ArityError()
	}

	// The argument must be a string
	str := args[0].ToString()

	// Get the output
	return primitive.String(fmt.Sprintf("%X", sha256.Sum256([]byte(str))))
}

// shellFn runs a command via the shell
func shellFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {

	// We need one argument
	if len(args) != 1 {
		return primitive.ArityError()
	}

	// The argument must be a list
	lst, ok := args[0].(primitive.List)
	if !ok {
		return primitive.Error("argument not a list")
	}

	// An empty list is no good
	if len(lst) < 1 {
		return primitive.Error("the list must be non-empty")
	}

	// Command to  run, and arguments
	cArgs := []string{}

	for _, arg := range lst {
		cArgs = append(cArgs, arg.ToString())
	}

	// If we're running a test-case we'll stop here, because
	// fuzzing might run commands.
	if os.Getenv("FUZZ") != "" {
		return primitive.List{}
	}

	cmd := exec.Command(cArgs[0], cArgs[1:]...)
	var outb, errb bytes.Buffer
	cmd.Stdout = &outb
	cmd.Stderr = &errb
	err := cmd.Run()
	if err != nil {
		return primitive.Error(fmt.Sprintf("error running command %s:%s", lst, err))
	}

	var ret primitive.List
	ret = append(ret, primitive.String(outb.String()))
	ret = append(ret, primitive.String(errb.String()))

	return ret
}

// sortFn implements (sort)
func sortFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {
	// If we have only a single argument
	if len(args) != 1 {
		return primitive.ArityError()
	}

	// Which is a list
	if _, ok := args[0].(primitive.List); !ok {
		return primitive.Error("argument not a list")
	}

	// Cast
	l := args[0].(primitive.List)

	// Copy
	var c primitive.List
	c = append(c, l...)

	// Sort the copy of the list
	sort.Slice(c, func(i, j int) bool {

		// If we have numbers we can sort
		if _, ok := c[i].(primitive.Number); ok {
			if _, ok := c[j].(primitive.Number); ok {

				a, _ := strconv.ParseFloat(c[i].ToString(), 64)
				b, _ := strconv.ParseFloat(c[j].ToString(), 64)

				return a < b
			}
		}

		// Otherwise we sort as strings
		a := c[i].ToString()
		b := c[j].ToString()
		return a < b
	})

	return c

}

// sourceFn implements (source)
func sourceFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {
	// We need a single argument
	if len(args) != 1 {
		return primitive.ArityError()
	}

	// Which is a function
	proc, ok := args[0].(*primitive.Procedure)

	if !ok {
		return primitive.Error("argument not a procedure")
	}

	if proc.F != nil {
		return primitive.Error("procedure is implemented in golang")
	}

	// Return value
	return primitive.String(proc.ToString())
}


// (split "str" "by")
func splitFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {

	// We require two arguments
	if len(args) != 2 {
		return primitive.ArityError()
	}

	// Both arguments must be strings
	if _, ok := args[0].(primitive.String); !ok {
		return primitive.Error("argument not a string")
	}
	if _, ok := args[1].(primitive.String); !ok {
		return primitive.Error("argument not a string")
	}

	// split
	out := strings.Split(args[0].ToString(), args[1].ToString())

	var c primitive.List

	for _, x := range out {
		c = append(c, primitive.String(x))
	}

	return c
}

// (sprintf "fmt" "arg1" ... "argN")
func sprintfFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {

	// we need 2+ arguments
	if len(args) < 2 {
		return primitive.ArityError()
	}

	// OK format-string
	frmt := expandStr(args[0].ToString())
	parm := []any{}

	for _, a := range args[1:] {

		// If we can use ToNative then do that,
		// otherwise fall back to outputting a string.
		native, ok := a.(primitive.ToNative)
		if ok {
			parm = append(parm, native.ToInterface())
		} else {
			parm = append(parm, a.ToString())
		}
	}

	out := fmt.Sprintf(frmt, parm...)
	return primitive.String(out)
}

// strFn implements "str"
func strFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {
	if len(args) != 1 {
		return primitive.ArityError()
	}
	return primitive.String(args[0].ToString())
}

// stringEqualsFn implements "string="
func stringEqualsFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {
	if len(args) != 2 {
		return primitive.ArityError()
	}

	a, ok1 := args[0].(primitive.String)
	if !ok1 {
		return primitive.Error("argument not a string")
	}

	b, ok2 := args[1].(primitive.String)
	if !ok2 {
		return primitive.Error("argument not a string")
	}
	return primitive.Bool(a == b)
}

// stringLtFn implements "string<"
func stringLtFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {
	if len(args) != 2 {
		return primitive.ArityError()
	}

	a, ok1 := args[0].(primitive.String)
	if !ok1 {
		return primitive.Error("argument not a string")
	}

	b, ok2 := args[1].(primitive.String)
	if !ok2 {
		return primitive.Error("argument not a string")
	}
	return primitive.Bool(a < b)
}


// timeFn returns the current (HH, MM, SS) as a list.
func timeFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {
	var ret primitive.List

	t := time.Now()

	hr := t.Hour()
	mn := t.Minute()
	sc := t.Second()

	ret = append(ret, primitive.Number(hr))
	ret = append(ret, primitive.Number(mn))
	ret = append(ret, primitive.Number(sc))

	return ret
}

// typeFn implements "type"
func typeFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {
	if len(args) != 1 {
		return primitive.ArityError()
	}
	return primitive.String(args[0].Type())
}

// valsFn is the implementation of `(vals hash)`
func valsFn(env *env.Environment, args []primitive.Primitive) primitive.Primitive {

	// We need a single argument
	if len(args) != 1 {
		return primitive.ArityError()
	}

	// First is a Hash
	if _, ok := args[0].(primitive.Hash); !ok {
		return primitive.Error("argument not a hash")
	}

	// Create the list to hold the result
	var c primitive.List

	// Cast the argument
	tmp := args[0].(primitive.Hash)

	// Get the keys as a list
	keys := []string{}

	// Add the keys
	for x := range tmp.Entries {
		keys = append(keys, x)
	}

	// Sort the list
	sort.Strings(keys)

	// Now append the value
	for _, x := range keys {
		c = append(c, tmp.Entries[x])
	}

	return c
}
