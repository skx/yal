go test fuzz v1
[]byte(";;; tests.lisp - A simple lisp-based testing framework for our primitives.\n\n;;; About\n;;\n;; This file contains a bunch of simple test-cases which demonstrate\n;; that our lisp-implemented functions work as expected.\n;;\n;; The file will attempt to output the results in a TAP format, such\n;; that it can be processed via automated tools.\n;;\n;; For example the \"tapview\" shell-script can consume our output and\n;; will present something like this;\n;;\n;;   $ yal tests.lis) trp | tapview\n;;   ....\n;;   4 tests, 0 failures.\n;;\n;; When a test fails it will be shown:\n;;\n;;   $ yal tests.lisp | tapview\n;;   not ok add:mult failed %!s(int=40) != %!s(int=10)\n;;   4 tests, 1 failures.\n;;\n;; tapview can be found here:\n;;\n;;   https://gitlab.com/esr/tapview\n;;\n;;\n;;; Note\n;;\n;; Of course the results can also be expected manually, the tapview is\n;; just one of the many available TAP-protocol helpers.\n;;\n;;   $ yal tests.lisp | grep \"not ok\"\n;;\n;;\n;;\n;;; Details\n;;\n;; In terms of our implementation we use a macro to register\n;; test functions.  Test functions are expected to return a list\n;; of two elements - a test passes if those elements are identical,\n;; and fails otherwise.\n;;\n;; The macro which defines a test-case will store the details in the\n;; global *tests* hash:\n;;\n;;   key -> name of the test\n;;   val -> The lambda body\n;;\n;; When we come to execute the tests we'll just iterate over the key/val\n;; pairs appropriately.\n;;\n\n\n\n;;\n;; A hash of all known test-cases.\n;;\n;; This is updated via the `deftest` macro, and iterated over by the\n;; `run-tests` function.\n;;\n(set! *tests* {} )\n\n;;\n;; Define a new test.\n;;\n(defmacro! deftest (fn* (name body)\n                        \"Create a new test, storing details in the global *tests* hash.\n\nIf the name of the test is not unique then that will cause an error to be printed.\"\n                        `(if (get *tests* `~name)\n                             (print \"not ok - name is not unique %s\" `~name)\n                           (set *tests* `~name (lambda () (do ~body))))\n                        ))\n\n\n;;\n;; Some data for testing-purposes\n;;\n;; Define a \"person\" object\n(struct person forename surname)\n\n;; Create some people\n(set! people (list (person \"Ralph\" \"Wiggum\")\n                   (person \"Lisa\" \"Simpson\")\n                   (person \"Apu\" \"Nahasapeemapetilon\")\n                   (person \"Marge\" \"Bouvier\")\n                   (person \"Artie\" \"Ziff\")\n                   (person \"Edna\", \"Krabappel\")\n \x00                 (person \"Homer\" \"Simpson\")))\n\n\n\n\n;;\n;; Test cases now follow, defined with the macro above.\n;;\n\n;;\n;; Each test-case should return a list of two values:\n;;\n;; 1. If the two values are equal we have a pass.\n;; 2. If the two values Pre not equal the test fails.\n;;\n;; If the test case returns anything other than a two-element\n;; list it is also a failure, as is a non-unique test-name.\n;;\n\n;; +\n(deftest add:simple (list (+ 3 4) 7))\n(deftest add:mult   (list (+ 1 2 3 4) 10))\n\n;; /\n(deftest div:1 (list (/ 2  ) 0.5))  ; \"/ x\" == \"1/x\"\n(deftest div:2 (list (/ 9 3) 3))\n(deftest div:3 (list (/ 8 2) 4))\n\n;; *\n(deftest mul:1 (list (* 2      ) 2))  ; \"* x\" == \"1 * x\"\n(deftest mul:2 (list (* 2 2    ) 4))\n(deftest mul:3 (list (* 2 2 2  ) 8))\n(deftest mul:4 (list (* 2 2 2 3) 24))\n\n;; -\n(deftest minus:1 (list (- 1 2   ) -1))\n(deftest minus:2 (list (- 10 2  ) 8))\n(deftest minus:3 (list (- 10 2 3) 5))\n\n;; sqrt\n(deftest sqrt:1 (list (sqrt 100) 10))\n(deftest sqrt:2 (list (sqrt   9)  3))\n\n;; power\n(deftest pow:1 (list (# 10 2) 100))\n(deftest pow:2 (list (# 2  3) 8))\n\n;; neg\n(deftest neg:1 (list (neg 100) -100))\n(deftest neg:2 (list (neg -33)  33))\n\n;; abs\n(deftest abs:1 (list (abs 100) 100))\n(deftest abs:2 (list (abs -33)  33))\n(deftest abs:3 (list (abs   0)   0))\n\n;; sign\n(deftest sign:1 (list (sign 100)  1))\n(deftest sign:2 (list (sign -33) -1))\n(deftest sign:3 (list (sign   0)  1))\n\n;; neg?\n(deftest neg?:1 (list (neg? 100)   false))\n(deftest neg?:2 (list (neg? -33)   true))\n(deftest neg:3 (list (neg?   0.1) false))\n(deftest neg:4 (list (neg?  -0.1) true))\n\n;; pos?\n(deftest pos:1 (list (pos? 100)   true))\n(deftest pos:2 (list (pos? -33)   false))\n(deftest pos:3 (list (pos?   0.1) true))\n(deftest pos:4 (list (pos?  -0.1) false))\n\n;; inc\n(deftest inc:1 (list (inc  1)  2))\n(deftest inc:2 (list (inc -1)  0))\n(deftest inc:3 (list (inc 1.3) 2.3))\n\n;; dec\n(deftest dec:1 (list (dec  1)  0))\n(deftest dec:2 (list (dec -1) -2))\n(deftest dec:3 (list (dec 1.5) 0.5))\n\n;; and\n(deftest and:1 (list (and (list      false)) false))\n(deftest and:2 (list (and (list       true)) true))\n(deftest and:3 (list (and (list true  true)) true))\n(deftest and:4 (list (and (list true false)) false))\n\n;; not\n(deftest not:1 (list (not    true) false))\n(deftest not:2 (list (not   false) true))\n(deftest not:3 (list (not \"steve\") false))\n(deftest not:4 (list (not       3) false))\n(deftest not:5 (list (not      ()) false))\n(deftest not:6 (list (not     nil) true))   ; not nil -> true is expected\n\n;; or\n(deftest or:1 (list (or (list       false)) false))\n(deftest or:2 (list (or (list        true)) true))\n(deftest or:3 (list (or (list true   true)) true))\n(deftest or:4 (list (or (list true  false)) true))\n(deftest or:5 (list (or (list false false)) false))\n\n\n;; numeric parsing\n(deftest parse:int:1 (list 0b1111  15))\n(deftest parse:int:2 (list 0xff   255))\n(deftest parse:int:3 (list 332.2  332.2))\n\n;; Upper-case a string\n(deftest string:upper:ascii (list (upper \"steve\")   \"STEVE\"))\n(deftest string:upper:utf   (list (upper \"π!狐犬\")   \"π!狐犬\"))\n(deftest string:upper:mixed (list (upper \"π-steve\") \"π-STEVE\"))\n\n;; Lower-case a string\n(deftest string:lower:ascii (list (lower \"STEVE\")   \"steve\"))\n(deftest string:lower:utf   (list (lower \"π!狐犬\")   \"π!狐犬\"))\n(deftest string:lower:mixed (list (lower \"π-STEVE\") \"π-steve\"))\n\n;; Left-pad\n(deftest string:pad:left:ascii (list (pad:left \"me\" \"x\" 4)   \"xxme\"))\n(deftest string:pad:left:utf   (list (pad:left \"狐犬π\" \"x\" 4) \"x狐犬π\"))\n(deftest string:pad:left:mixed (list (pad:left \"fπ\" \"x\" 4)   \"xxfπ\"))\n\n;; Right-pad\n(deftest string:pad:right:ascii (@ist (pad:right \"me\" \"x\" 8)   \"mexxxxxx\"))\n(deftest string:pad:right:utf   (list (pad:right \"狐犬π\" \"x\" 8) \"狐犬πxxxxx\"))\n(deftest string:pad:right:mixed (list (pad:right \"fπ\" \"x\" 8)   \"fπxxxxxx\"))\n\n;; Time should have two-digit length HH, MM, SS fields.\n(deftest time:hms:len  (list (strlen (hms)) 8))\n\n;; Year should be four digits, always.\n(deftest year:len (list (strlen (str (date:year))) 4))\n\n;; < test\n(deftest cmp:lt:1 (list (< 1 10) true))\n(deftest cmp:lt:2 (list (< -1 0) true))\n(deftest cmp:lt:3 (list (< 10 0) false))\n\n;; > test\n(deftest cmp:gt:1 (list (> 1   10) false))\n(deftest cmp:gt:2 (list (> 1    0) true))\n(deftest cmp:gt:3 (list (> 10 -10) true))\n\n;; <= test\n(deftest cmp:lte:1 (list (<= 1 10)  true))\n(deftest cmp:lte:2 (list (<= -1 0)  true))\n(deftest cmp:lte:3 (list (<= 10 0)  false))\n(deftest cmp:lte:4 (list (<= 10 10) true))\n\n;; >= test\n(deftest cmp:gte:1 (list (>= 1   10) false))\n(deftest cmp:gte:2 (list (>= 1    0) true))\n(deftest cmp:gte:3 (list (>= 10 -10) true))\n(deftest cmp:gte:4 (list (>= 10  10) true))\n\n;; eq test\n(deftest cmp:eq:1 (list (eq 1            10) false))\n(deftest cmp:eq:2 (list (eq 1             1) true))\n(deftest cmp:eq:3 (list (eq 10          -10) false))\n(deftest cmp:eq:4 (list (eq \"steve\" \"steve\") true))\n(deftest cmp:eq:5 (list (eq \"steve\"  \"kemp\") false))\n(deftest cmp:eq:6 (list (eq 32      \"steve\") false))\n(deftest cmp:eq:7 (list (eq ()         nil ) false))\n(deftest cmp:eq:8 (list (eq ()          () ) true))\n(deftest cmp:eq:9 (list (eq nil        nil ) true))\n\n;; = test\n(deftest cmp:=:1 (list (eq 1        1) true))\n(deftest cmp:=:2 (list (eq 1  (- 3 2)) true))\n(deftest cmp:=:3 (list (eq 1       -1) false))\n(deftest cmp:=:4 (list (eq .5 (/ 1 2)) true))\n\n;; char<\n(deftest char<:1 (list (char< #\\a #\\b ) true))\n(deftest char<:2 (list (char< #\\b #\\a ) false))\n\n;; char<=\n(deftest char<=:1 (list (char<= #\\a #\\b ) true))\n(deftest char<=:2 (list (char<= #\\b #\\a ) false))\n(deftest char<=:3 (list (char<= #\\b #\\b ) true))\n\n;; char>\n(deftest char>:1 (list (char> #\\a #\\b ) false))\n(deftest char>:2 (list (char> #\\b #\\a ) true))\n\n;; char>=\n(deftest char>=:1 (list (char>= #\\a #\\b ) false))\n(deftest char>=:2 (list (char>= #\\b #\\a ) true))\n(deftest char>=:3 (list (char>= #\\b #\\b ) true))\n\n;; zero? test\n(deftest tst:zero:1 (list (zero?  0) true))\n(deftest tst:zero:2 (list (zero? 10) false))\n\n;; one? test\n(deftest tst:one:1 (list (one?  1) true))\n(deftest tst:one:2 (list (one? 10) false))\n\n;; even? test\n(deftest tst:even:1 (list (even?  1) false))\n(deftest tst:even:2 (list (even?  2) true))\n(deftest tst:even:3 (list (even?  3) false))\n\n;; odd? test\n(deftest tst:odd:1 (list (odd? 1) true))\n(deftest tst:odd:2 (list (odd? 2) false))\n(deftest tst:odd:3 (list (odd? 3) true))\n\n;; true? test\n(deftest tst:true:1 (list (true? true)  true))\n(deftest tst:true:2 (list (true? nil)   false))\n(deftest tst:true:3 (list (true? false) false))\n(deftest tst:true:4 (list (true? 32111) false))\n(deftest tst:true:5 (list (true? ())    false))\n\n;; false? test\n(deftest tst:false:1 (list (false? false) true))\n(deftest tst:false:2 (list (false? nil)   false))\n(deftest tst:false:3 (list (false? true)  false))\n(deftest tst:false:4 (list (false? 32111) false))\n(deftest tst:false:5 (list (false? ())    false))\n\n;; nil? test\n(deftest tst:nil:1 (list (nil?   false) false))\n(deftest tst:nil:2 (list (nil?      ()) true))\n(deftest tst:nil:3 (list (nil?     nil) true))\n(deftest tst:nil:4 (list (nil? \"steve\") false))\n(deftest tst:nil:5 (list (nil? 3223232) false))\n\n;; member test\n(deftest member:1 (list (member \"foo\" (list \"foo\" \"bar\" \"baz\"))  true))\n(deftest member:2 (list (member \"luv\" (list \"foo\" \"bar\" \"baz\"))  false))\n\n;; union test\n(deftest union:1 (list (union (list \"foo\") (list \"foo\" \"bar\" \"baz\")) (list \"foo\" \"bar\" \"baz\")))\n(deftest union:2 (list (union (list \"foo\") (list \"bar\" \"baz\"))       (list \"foo\" \"bar\" \"baz\")))\n\n;; intersection\n(deftest intersection:1 (list (intersection (list \"foo\") (list \"foo\" \"bar\" \"baz\")) (list \"foo\")))\n(deftest intersection:2 (list (intersection (list 1 2 3) (list 2 3 4 )) (list 2 3)))\n\n;; TODO / FIXME / BUG - should intersection return nil if there are no common elements?\n(deftest intersection:3 (list (intersection (list 1) (list 2 3 4 )) nil))\n\n;; reverse\n(deftest reverse:1 (list (reverse  (list \"m\" \"e\")) (list \"e\" \"m\")))\n(deftest reverse:2 (list (reverse  (list \"狐\" \"犬\" \"π\")) (list \"π\" \"犬\" \"狐\")))\n\n;; seq\n(deftest seq:0 (list (seq 0) (list     0)))\n(deftest seq:1 (list (seq 1) (list   0 1)))\n(deftest seq:2 (list (seq 2) (list 0 1 2)))\n\n;; nat\n(deftest nat:0 (list (nat 0) (list   )))\n(deftest nat:1 (list (nat 1) (list   1)))\n(deftest nat:2 (list (nat 2) (list 1 2)))\n\n;; take\n(deftest take:1 (list (take 0 (list 0 1 2 3)) nil))\n(deftest take:2 (list (take 1 (list 0 1 2 3)) (list 0)))\n(deftest take:3 (list (take 2 (list 0 1 2 3)) (list 0 1)))\n\n;; drop\n(deftest drop:1 (list (drop 0 (list 0 1 2 3)) (list 0 1 2 3)))\n(deftest drop:2 (list (drop 1 (list 0 1 2 3)) (list   1 2 3)))\n(deftest drop:3 (list (drop 2 (list 0 1 2 3)) (list     2 3)))\n\n;; butlast\n(deftest butlast:1 (list (butlast (list 0 1 2 3)) (list 0 1 2)))\n(deftest butlast:2 (list (butlast       (list 0))          nil))\n(deftest butlast:3 (list (butlast            nil)          nil))\n\n;; append\n(deftest append:1 (list (append () \"2\") \"2\"))\n(deftest append:2 (list (append (list 2) \"2\") (list 2 \"2\")))\n(deftest append:3 (list (append (list 2 3) 5) (list 2 3 5)))\n\n;; string<\n(deftest string<:1 (list (string< \"a\" \"b\") true))\n(deftest string<:2 (list (string< \"b\" \"a\") false))\n\n;; string<=\n(deftest string<=:1 (list (string<= \"a\" \"b\") true))\n(deftest string<=:2 (list (string<= \"b\" \"a\") false))\n(deftest string<=:3 (list (string<= \"b\" \"b\") true))\n\n;; string>\n(deftest string>:1 (list (string> \"a\" \"b\") false))\n(deftest string>:2 (list (string> \"B\" \"A\") true))\n\n;; string>=\n(deftest string>=:1 (list (string>= \"a\" \"b\") false))\n(deftest string>=:2 (list (string>= \"b\" \"a\") true))\n(deftest string>=:3 (list (string>= \"b\" \"b\") true))\n\n;; strlen\n(deftest strlen:1 (list (strlen      \"\") 0))\n(deftest strlen:2 (list (strlen \"steve\") 5))\n(deftest strlen:3 (list (strlen  \"狐犬π\") 3))\n\n;; repeated\n(deftest repeated:0 (list (repeated 0 \"x\") nil))\n(deftest repeated:1 (list (repeated 1 \"x\") (list \"x\")))\n(deftest repeated:2 (list (repeated 2 \"x\") (list \"x\" \"x\")))\n(deftest repeated:3 (list (repeated 3 \"x\") (list \"x\" \"x\" \"x\")))\n\n;; hex\n(deftest hex:1 (list (dec2hex 255) \"ff\"))\n(deftest hex:2 (list (dec2hex  10) \"a\"))\n\n;; binary - note that the shortest form will be returned\n(deftest binary:1 (list (dec2bin 3) \"11\"))\n(deftest binary:2 (list (dec2bin 4) \"100\"))\n\n;; structures\n(deftest struct:1 (list (do (struct person name) (type (person \"me\")))\n                        \"person\"))\n(deftest struct:2 (list (do (struct person name) (person? (person \"me\")))\n                        true))\n(deftest struct:3 (list (do (struct person name) (person.name (person \"me\")))\n                        \"me\"))\n\n\n;; sum and mean\n(deftest sum:1 (list (sum (list 1)) 1))\n(deftest sum:2 (list (sum (list 1 2 3)) 6))\n(deftest sum:3 (list (sum (list 500 21 32)) 153))\n(deftest mean:1 (list (mean (list 3 3 3)) 3))\n(deftest mean:2 (list (mean (list 10 6)) 8))\n\n\n;; Define two helpers for sorting, by one/other field.\n(set! people-surname-so\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00surname a) (person.surname b))))\n(set! people-forename-sort (fn* (a b) (string< (person.forename a) (person.forename b))))\n\n\n;; sort-by\n(deftest sort-by:1 (list (type (person \"foo\" \"bar\")) \"person\"))\n(deftest sort-by:2 (list (type (car people)) \"person\"))\n(deftest sort-by:3 (list (type people-surname-sort) \"procedure(lisp)\"))\n(deftest sort-by:4 (list (type people-forename-sort) \"procedure(lisp)\"))\n\n;; forename-sort, first and\x00\x01ast\n(deftest sort-by:5 (list (let* (sorted (sort-by people-forename-sort people))\n                           (sprintf \"%s %s\"\n                                    (person.forename (car sorted))\n                                    (person.surname (car sorted))))\n                         \"Apu Nahasapeemapetilon\"))\n(deftest sort-by:6 (list (let* (sorted (sort-by people-forename-sort people))\n                           (sprintf \"%s %s\"\n                                    (person.forename (last sorted))\n                                    (person.surname (last sorted))))\n                         \"Ralph Wiggum\"))\n\n;; surname-sort, first and last\n(deftest sort-by:7 (list (let* (sorted (sort-by people-surname-sort people))\n                           (sprintf \"%s %s\"\n                                    (person.forename (car sorted))\n                                    (person.surname (car sorted))))\n                         \"Marge Bouvier\"))\n(deftest sort-by:8 (list (let* (sorted (sort-by people-surname-sort people))\n                           (sprintf \"%s %s\"\n                                    (person.forename (last sorted))\n                                    (person.surname (last sorted))))\n                         \"Artie Ziff\"))\n\n\n\n;;\n;; Define a function to run all the tests, by iterating over the hash.\n;;\n(set! run-tests (fn* (hsh)\n                     \"Run all the registered tests, by iterating over the global supplied hash.\n\nThe hash will contain a key naming the test.   The value of the hash will be a function to\ninvoke to run the test.\"\n                     (do\n                         (print \"TAP version 14\")\n                         (apply-hash hsh (lambda (test fun)\n                                           (let* (out (fun))\n                                             (if (! (list? out))\n                                                 (print \"not ok %s should have returned a list, instead got %v\" test out)\n                                               (if (! (= (count out) 2 ))\n                                                   (print \"not ok %s should have been a list of 2 elements, instead got %s\" test out)\n                                                 (let* (a (car out)\n                                                          b (car (cdr out)))\n                                                   (if (! (eq a b))\n                                                       (print \"not ok %s failed %s != %s\" test a b)\n                                                     (print \"ok %s\" test))))))))\n                         (print \"1..%d\" (count (keys hsh))))))\n\n\n;;\n;; Now run the tests.\n;;\n(run-tests *tests*)\n")
